# Swifty API - GitLab CI/CD Pipeline

stages:
  - validate
  - test
  - build
  - security
  - package
  - version

variables:
  # Node.js
  NODE_ENV: test
  NPM_CONFIG_CACHE: "$CI_PROJECT_DIR/.npm"

  # Docker
  DOCKER_HOST: tcp://docker:2376
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_TLS_VERIFY: 1
  DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  DOCKER_DRIVER: overlay2

  # Container Registry
  REGISTRY_IMAGE: $CI_REGISTRY_IMAGE
  DOCKER_BUILDKIT: 1

  # Semantic Versioning
  VERSION_FILE: VERSION

# Global cache configuration
cache:
  key:
    files:
      - package-lock.json
  paths:
    - .npm/
  policy: pull
  fallback_keys:
    - ${CI_DEFAULT_BRANCH}

# Include version management
include:
  - local: '.gitlab/version.gitlab-ci.yml'

# ============================================
# VALIDATION STAGE
# ============================================

lint:
  stage: validate
  image: node:20-alpine
  cache:
    policy: pull-push
  before_script:
    - npm ci --prefer-offline --no-audit --no-fund
  script:
    - npx eslint --ext .js . --max-warnings=0
    - npx prettier -c "**/*.{js,json,md}"
  only:
    - merge_requests
    - main
    - develop
    - tags

# ============================================
# TEST STAGE
# ============================================

unit_test:
  stage: test
  image: node:20-alpine
  dependencies: []
  variables:
    JEST_JUNIT_OUTPUT_DIR: "test-reports"
    JEST_JUNIT_OUTPUT_NAME: "junit.xml"
    NODE_ENV: test
  before_script:
    - rm -rf .cov test-reports || true
    - mkdir -p .cov test-reports
    - npm ci --prefer-offline --no-audit --no-fund
  script:
    - |
      npm test -- --ci --passWithNoTests \
        --coverage --coverageDirectory=.cov \
        --coverageReporters=cobertura \
        --reporters=default --reporters=jest-junit
    # Fallback for empty test results
    - '[ -f test-reports/junit.xml ] || echo "<?xml version=\"1.0\"?><testsuites name=\"empty\" tests=\"0\" failures=\"0\"/>" > test-reports/junit.xml'
    - '[ -f .cov/cobertura-coverage.xml ] || echo "<?xml version=\"1.0\"?><coverage lines-valid=\"0\" lines-covered=\"0\" line-rate=\"0\" version=\"0\"/>" > .cov/cobertura-coverage.xml'
  artifacts:
    when: always
    reports:
      junit: test-reports/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: .cov/cobertura-coverage.xml
    expire_in: 1 week
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  only:
    - merge_requests
    - main
    - develop
    - tags

# ============================================
# BUILD STAGE
# ============================================

build_docker:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_BUILDKIT: 1
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - export DOCKER_IMAGE=$REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - export DOCKER_IMAGE_LATEST=$REGISTRY_IMAGE:latest
    - docker build --target build -t $DOCKER_IMAGE-build .
    - docker build --target production -t $DOCKER_IMAGE -t $DOCKER_IMAGE_LATEST .
    - docker push $DOCKER_IMAGE
    - docker push $DOCKER_IMAGE_LATEST
  only:
    - main
    - develop
    - merge_requests
    - tags
  artifacts:
    reports:
      # Store the built image reference for subsequent jobs
      dotenv: build.env

# ============================================
# SECURITY STAGE
# ============================================

security_scan:
  stage: security
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_IMAGE: $REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    # Pull the image
    - docker pull $DOCKER_IMAGE
    # Run Trivy security scan
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock
      aquasec/trivy:latest image --exit-code 0 --no-progress --format json $DOCKER_IMAGE > trivy-results.json
    # Check for high/critical vulnerabilities
    - |
      if [ $(jq '.Results[].Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL") | length' trivy-results.json | wc -l) -gt 0 ]; then
        echo "High or Critical vulnerabilities found!"
        jq '.Results[].Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")' trivy-results.json
        exit 1
      fi
  artifacts:
    paths:
      - trivy-results.json
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - tags
  allow_failure: true

dependency_scan:
  stage: security
  image: node:20-alpine
  dependencies: []
  cache:
    policy: pull
  script:
    - npm ci --production --prefer-offline --no-audit --no-fund
    - npm audit --production --audit-level=high --json > audit-results.json || true
    # Parse audit results and fail on high severity issues
    - |
      if [ $(jq '.vulnerabilities.high // 0' audit-results.json) -gt 0 ]; then
        echo "High severity vulnerabilities found in dependencies!"
        npm audit --production --audit-level=high
        exit 1
      fi
  artifacts:
    paths:
      - audit-results.json
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - tags
  allow_failure: true

# ============================================
# PACKAGE STAGE
# ============================================

# Multi-architecture build for production releases
build_multiarch:
  stage: package
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_BUILDKIT: 1
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    # Enable experimental features for buildx
    - export DOCKER_CLI_EXPERIMENTAL=enabled
    - docker buildx create --use --name multiarch-builder || docker buildx use multiarch-builder
    - docker buildx inspect --bootstrap

    # Build and push multi-architecture image
    - export VERSION_TAG=$(cat $VERSION_FILE)
    - export DOCKER_IMAGE_VERSION=$REGISTRY_IMAGE:$VERSION_TAG
    - export DOCKER_IMAGE_MAJOR=$REGISTRY_IMAGE:$(echo $VERSION_TAG | cut -d. -f1)
    - export DOCKER_IMAGE_MINOR=$REGISTRY_IMAGE:$(echo $VERSION_TAG | cut -d. -f1-2)

    - docker buildx build --platform linux/amd64,linux/arm64
      --target production
      --tag $DOCKER_IMAGE_VERSION
      --tag $DOCKER_IMAGE_MAJOR
      --tag $DOCKER_IMAGE_MINOR
      --push .

    # Also push to latest for main branch
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        docker buildx build --platform linux/amd64,linux/arm64 \
          --target production \
          --tag $REGISTRY_IMAGE:latest \
          --push .
      fi
  only:
    - tags
  dependencies:
    - build_docker

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_TAG
